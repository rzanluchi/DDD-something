

class MessageDispatcher(object):

    def __init__(self, event_store):
        self.event_store = event_store
        self.command_handlers = {}
        self.event_subscribers = {}

    def add_handler_for(self, command, handler):
        """ Bind a handler for a specific command
        """
        if not self.command_handlers[command]:
            self.command_handlers[command] = [handler]
        else:
            self.command_handlers[command].append(handler)

    def add_subscriber_for(self, event, subscriber):
        """ Bind a listener for a specific event
        """
        if not self.event_subscribers[event]:
            self.event_subscribers[event] = [subscriber]
        else:
            self.event_subscribers[event].append([subscriber])

    def publish_events(self, events):
        """ Will publish an event to all subscribers
        """
        for event in events:
            if event.event_name in self.event_subscribers.keys():
                for sub in self.event_subscribers[event.event_name]:
                    sub.apply_events([event])

    def publish_command(self, command):
        """ Will publish an event to all subscribers
        """
        if command.command_name in self.command_handlers.keys():
            for handler in self.command_handlers[command.command_name]:
                self._execute_command(handler, command)

    def _execute_command(self, handler, command):
        """ Internal method that executes the command using the handler
        associated. It will load the previous events based on the
        handler's (aggregate) id and then will execute the command.
        By the end it will publish all events generated by the aggegate
        """
        past_events = self._load_events_for(handler, command.id)
        handler.apply_events(past_events)
        new_events = handler.handle(command)
        self._store_events_for(handler, new_events)
        self.publish_events(new_events)

    def _store_events_for(self, aggregate, events):
        return self.event_store.store(aggregate, events)

    def _load_events_for(self, aggregate, id):
        return self.event_store.load(aggregate, id)
